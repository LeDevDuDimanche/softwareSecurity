#!/usr/bin/env python3

"""Script to run exploit 4.

Instructions: `make` the project, then run this script.

This script requires Python 3.6 or higher."""


import pathlib
import shutil
import subprocess
import time


# `HERE` is the directory this script is located in.
HERE = pathlib.Path(__file__).resolve().parent
TEMP_DIR = HERE / 'temp'
BIN_DIR = HERE.parent.parent / 'bin'
BASE_CONFIG = HERE.parent / 'grass.conf'
EXPLOIT_PATH = HERE / 'exploit.in'

CLIENT = 'client'
SERVER = 'server'
BINARIES = CLIENT, SERVER
CLIENT_PATH = TEMP_DIR / CLIENT
SERVER_PATH = TEMP_DIR / SERVER
CONFIG_PATH = TEMP_DIR / 'grass.conf'
REPO_DIR = TEMP_DIR / 'repo'
IP_ADDRESS = '127.0.0.1'
PORT = 6543

STARTUP_WAIT = 0.01
TIMEOUT = 3.0


def setup():
    """Perform setup and return True if it succeeded."""

    try:
        TEMP_DIR.mkdir(exist_ok=True)
    except OSError:
        print("Error in setup: couldn't make temporary directory")
        return False

    # Copy the binaries into the temporary directory because the server must be
    # in the same directory as the config file.
    for binary in BINARIES:
        try:
            shutil.copy(BIN_DIR / binary, TEMP_DIR / binary)
        except OSError:
            print(f"Error in setup: couldn't copy {binary}.  (Run `make`!)")
            return False

    try:
        shutil.copy(BASE_CONFIG, CONFIG_PATH)
    except OSError:
        print("Error in setup: couldn't copy config")
        return False

    return True


def cleanup():
    """Clean up after."""

    try:
        CONFIG_PATH.unlink()
    except OSError:
        print("Error in cleanup: couldn't remove config file")

    for binary in BINARIES:
        try:
            (TEMP_DIR / binary).unlink()
        except OSError:
            print(f"Error in cleanup: couldn't remove {binary}")

    try:
        TEMP_DIR.rmdir()
    except OSError:
        print("Error in cleanup: couldn't delete the temporary directory.  "
              "(Maybe it isn't empty!)")


def run_system(in_bytes):
    """Run a client and server and return their respective output.

    Raise a `subprocess.SubprocessError` on error."""

    client_args = IP_ADDRESS, str(PORT)
    return run_system_processes(client_args, in_bytes)


def run_system_processes(client_args, in_bytes):
    """Run a client and server and return their respective output bytes.

    Raise a `subprocess.SubprocessError` on error."""

    kwargs = dict(stdout=subprocess.PIPE, stderr=subprocess.DEVNULL,
                  cwd=TEMP_DIR)

    try:
        server_process = subprocess.Popen(str(SERVER_PATH), **kwargs)
    except OSError as e:
        message = f"Couldn't run the subprocesses: {e}"
        raise subprocess.SubprocessError(message) from None

    with server_process:
        try:
            time.sleep(STARTUP_WAIT)
            args = [str(CLIENT_PATH), *client_args]

            try:
                client = subprocess.run(args, **kwargs, input=in_bytes,
                                        timeout=TIMEOUT, check=True)
            except subprocess.TimeoutExpired as e:
                client_output = e.stdout
            else:
                client_output = client.stdout
        finally:
            server_process.kill()
            try:
                shutil.rmtree(REPO_DIR)
            except OSError as e:
                print(f"Warning in cleanup: Couldn't remove repo: {e}")

        server_output, _ = server_process.communicate()

    return client_output, server_output


def main():
    """Run the exploit."""
    exploit_bytes = EXPLOIT_PATH.read_bytes()
    try:
        if setup():
            run_system(exploit_bytes)
    finally:
        cleanup()


if __name__ == '__main__':
    main()
